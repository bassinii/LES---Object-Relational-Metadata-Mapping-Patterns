{"name":"LES - Object-Relational Metadata Mapping Patterns","tagline":"Trabalho 3 da disciplina de Laboratorio de Engenharia de Software","body":"# Metadata Mapping \r\n\r\nGuarda detalhes de mapeamento objeto-relacional em metadados.\r\n\r\n![](http://martinfowler.com/eaaCatalog/metaMapperSketch.gif)\r\n\r\nO código que lida com o mapeamento objeto-relacional descreve como os campos no banco de dados correspondem a campos em objetos.\r\n* Enfadonho\r\n* Repetitivo.\r\n\r\nUm mapeamento de metadados permite aos programadores definir os mapeamentos de uma forma simples, que então é processado pelo código genérico para realizar a leitura, inserção, e a atualização dos dados. \r\n\r\n## Como Funciona:\r\nA maior decisão em usar Metadados Mapeamento é a forma como as informações nos metadados se manifesta em termos de execução de código. Existem duas principais rotas a tomar:\r\n* Geração de código.\r\n* Programação reflexiva.\r\n\r\n### Geração de Código:\r\nA aplicação recebe como entrada metadados e cuja saída é o código-fonte das classes que fazem o mapeamento. \r\nAs classes geradas nunca devem ser editadas manualmente.\r\n\r\nMenos dinâmico: \r\n* Quaisquer alterações no mapeamento requerem recompilação e redistribuição.\r\n\r\n### Programação Reflexiva:\r\nTrata os métodos (e campos) como dados.\r\n\r\nO programa reflexivo pode ler o nome do campo ou do método em um arquivo de metadados e usá-los para realizar o mapeamento.\r\n\r\nÉ desencorajado de se usar programação reflexiva pois:\r\n* Lento.\r\n* Difícil depuração.\r\n\r\nPorem torna a aplicação mais flexível.\r\n\r\nNa maioria das vezes você mantenha os metadados em um formato de arquivo separado.\r\nAtualmente XML é uma escolha popular, pois proporciona estruturação hierárquica, libertando-o de escrever seus próprios analisadores e outras ferramentas.\r\nU\r\nm dos desafios dos metadados é que existem casos onde terá que ser adicionado uma grande complexidade de metadados, uma alternativa útil é sobrescrever o código genérico .\r\n\r\n## Quando Usá-lo:\r\nEsse padrão reduz muito a quantidade de trabalho para tratar o mapeamento em um banco de dados, mas o trabalho de configuração é requerido para preparar o framework. O mapeamento em metadados pode interferir na refatoração, mas por outro lado pode tornar a refatoração no banco de dados mais fácil, já que os metadados representam uma declaração na interface.\r\n\r\n## Exemplo: \r\n`\r\n\r\n`\r\n\r\n# Query Object (Objeto de Pesquisa) \r\n## Como funciona:\r\nUm objeto de pesquisa é um interpretador, pode-se criar a consulta fazendo referência a classes e a campos em vez de tabelas e colunas. É uma aplicação do padrão Interpretador destinado a representar uma consulta SQL.\r\nSuas principais tarefas são:\r\n* Permitir ao cliente formular consultas.\r\n* Transformar estruturas em objetos na string SQL. \r\n\r\nPode representar consultas na linguagem dos objetos na memória em vez da linguagem do esquema do banco de dados,\r\n* ou seja, usar nomes de objetos e campos em vez de usar nomes de tabelas e colunas.\r\n\r\nPara efetuar essa mudança o objeto de pesquisa precisa saber como está a estrutura do banco de dados, essa é uma habilidade que precisa de do Mapeamento de Metadados.\r\n\r\nUm uso do Objeto de pesquisa elimina pesquisas redundantes.\r\n* Se a consulta já foi vista basta consultar os objetos do Mapa de identidade, evitando assim uma ida ao banco de dados.\r\nOutra abordagem é para detectar consultas que são casos particulares de outras.\r\n\r\n* Uma variação permite que uma consulta seja especificada por um exemplo de objeto de domínio. Assim poderia ter um objeto com apenas um campo preenchido, o restante seria nulo.\r\n\r\n## Quando Usar:\r\nÉ um padrão bastante sofisticado para se construir, portanto a maioria dos projetos não usa.\r\n Vantagens desse padrão: \r\n* Manter esquemas de banco de dados encapsulados.\r\n* Suportar múltiplos banco de dados.\r\n* Otimizar consultas.\r\n* Suportar múltiplos esquemas.\r\n\r\n## Exemplo:\r\n`\r\n\r\n`\r\n\r\n# Repository (Repositório)\r\n## Como Funciona:\r\nEle é uma junção de outros padrões, ele se parece com um pequeno banco de dados orientado a objetos.\r\nExiste um objeto repositório que “simula” um banco de dados. \r\n\r\nAssim aplicação cliente não acesso a fonte de dados real, que pode ser um simples banco de dados relacional ou um fluxo XML, ou ainda a combinação de muitos bancos, no entanto ela acessa ao repositório através de métodos que recebem como parâmetros critérios usados para procurar objetos específicos que pertençam ao repositório. \r\n\r\nPodemos dizer que o repositório é uma grande coleção de dados e permite ao cliente procurar por objetos e não se preocupar com SQL. \r\n\r\nPara encontrar um objeto o cliente deve especificar os critérios de busca, tendo feito isso acontece a busca no repositório usando as informações que foram passadas, para então retornar uma lista de objetos ou um objeto do domínio que possa representar as informações que foram solicitadas.\r\n\r\nO código de um repositório se parece com uma coleção de objetos do domínio em memória. \r\nO repositório combina o Mapeamento em metadados com objeto de pesquisa, para gerar automaticamente o codigo SQL a partir dos critérios que foram passados.\r\n\r\nSua utilização pode melhorar a legibilidade e a clareza em um código que faz uso extensivo de consultas.\r\n\r\n## Quando Usar:\r\nEm sistemas grandes com muitos tipos de objetos de domínio e muitas pesquisas possíveis esse padrão reduz a quantidade o código necessário.\r\n\r\nPromove o padrão Especificação, que encapsula a consulta a ser realizada de uma forma puramente orientada a objeto.\r\n\r\n## Exemplo:\r\n`\r\n\r\n`","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}