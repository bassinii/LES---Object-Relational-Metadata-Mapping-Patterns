{"name":"LES - Object-Relational Metadata Mapping Patterns","tagline":"Trabalho 3 da disciplina de Laboratorio de Engenharia de Software","body":"# Metadata Mapping \r\n\r\nGuarda detalhes de mapeamento objeto-relacional em metadados.\r\n\r\n![](http://martinfowler.com/eaaCatalog/metaMapperSketch.gif)\r\n\r\nO código que lida com o mapeamento objeto-relacional descreve como os campos no banco de dados correspondem a campos em objetos.\r\n* Enfadonho\r\n* Repetitivo.\r\n\r\nUm mapeamento de metadados permite aos programadores definir os mapeamentos de uma forma simples, que então é processado pelo código genérico para realizar a leitura, inserção, e a atualização dos dados. \r\n\r\n## Como Funciona:\r\nA maior decisão em usar Metadados Mapeamento é a forma como as informações nos metadados se manifesta em termos de execução de código. Existem duas principais rotas a tomar:\r\n* Geração de código.\r\n* Programação reflexiva.\r\n\r\n### Geração de Código:\r\nA aplicação recebe como entrada metadados e cuja saída é o código-fonte das classes que fazem o mapeamento. \r\nAs classes geradas nunca devem ser editadas manualmente.\r\n\r\nMenos dinâmico: \r\n* Quaisquer alterações no mapeamento requerem recompilação e redistribuição.\r\n\r\n### Programação Reflexiva:\r\nTrata os métodos (e campos) como dados.\r\n\r\nO programa reflexivo pode ler o nome do campo ou do método em um arquivo de metadados e usá-los para realizar o mapeamento.\r\n\r\nÉ desencorajado de se usar programação reflexiva pois:\r\n* Lento.\r\n* Difícil depuração.\r\n\r\nPorem torna a aplicação mais flexível.\r\n\r\nNa maioria das vezes você mantenha os metadados em um formato de arquivo separado.\r\nAtualmente XML é uma escolha popular, pois proporciona estruturação hierárquica, libertando-o de escrever seus próprios analisadores e outras ferramentas.\r\n\r\nUm dos desafios dos metadados é que existem casos onde terá que ser adicionado uma grande complexidade de metadados, uma alternativa útil é sobrescrever o código genérico .\r\n\r\n## Quando Usar:\r\nEsse padrão reduz muito a quantidade de trabalho para tratar o mapeamento em um banco de dados, mas o trabalho de configuração é requerido para preparar o framework. O mapeamento em metadados pode interferir na refatoração, mas por outro lado pode tornar a refatoração no banco de dados mais fácil, já que os metadados representam uma declaração na interface.\r\n\r\n## Exemplo: \r\n\r\n* Classe que representa uma classe de domínio:\r\n\r\n`public class DomainObject {`\r\n\r\n    `private Long ID;`\r\n\r\n    `public DomainObject() {}`\r\n    \r\n    `public DomainObject(Long ID) {`\r\n        `this.ID = ID;`\r\n    `}`\r\n\r\n`}`\r\n\r\n* Classe que representa uma pessoa que vai ser mapeada pra uma tabela no banco de dados:\r\n\r\n`public class Person  extends DomainObject{`\r\n    \r\n    `private String lastname;`\r\n    `private String firstname;`\r\n    `private int numberOfDependents;`\r\n\r\n`}`\r\n\r\n\r\n* O mapa de dados contém uma coleção de mapas de colunas que mapeiam colunas na tabela de campos:\r\n\r\n`public class DataMap {`\r\n\r\n    `private Class domainClass;`\r\n    `private String tableName;`\r\n    `private List columnMaps = new ArrayList();`\r\n\r\n    `DataMap(Class<Person> aClass, String tableName) {`\r\n        `this.domainClass = aClass;`\r\n        `this.tableName = tableName;`\r\n        \r\n    `}`\r\n\r\n    `public String columnList() {`\r\n        `StringBuffer result = new StringBuffer(\"\tID\");`\r\n\r\n        `for (Iterator it = columnMaps.iterator(); it.hasNext();) {`\r\n            `result.append(\",\");`\r\n\r\n            `ColumnMap columnMap = (ColumnMap) it.next();`\r\n            `result.append(columnMap.getColumnName());`\r\n\r\n        `}`\r\n        `return result.toString();`\r\n\r\n    `}`\r\n    \r\n    `public String insertList() {`\r\n\r\n        `StringBuffer result = new StringBuffer();`\r\n        `for (int i = 0; i < columnMaps.size(); i++) {`\r\n\r\n            `result.append(\",\");`\r\n            `result.append(\"?\");`\r\n        `}`\r\n\r\n        `return result.toString();`\r\n    `}`\r\n\r\n    `public String updateList() {`\r\n\r\n        `StringBuffer result = new StringBuffer(\" SET \");`\r\n\r\n        `for (Iterator it = columnMaps.iterator(); it.hasNext();) {`\r\n            `ColumnMap columnMap = (ColumnMap) it.next();`\r\n            `result.append(columnMap.getColumnName());`\r\n            `result.append(\"=?,\");`\r\n\r\n        `}`\r\n\r\n        `result.setLength(result.length() - 1);`\r\n        `return result.toString();`\r\n\r\n    `}`\r\n\r\n    `public Iterator getColumns() {`\r\n        `return Collections.unmodifiableCollection(columnMaps).iterator();`\r\n    `}`\r\n\r\n    `void addColumn(String lastname, String varchar, String lastName) {`\r\n        `ColumnMap coluna = new ColumnMap(columnName, fieldName, this);`\r\n        `this.columnMaps.add(coluna);`\r\n    `}`\r\n\r\n`}`\r\n\r\n\r\n* O mapa de coluna faz o mapeamento entre um atributo de um objeto e um campo na tabela do banco:\r\n\r\n`public class ColumnMap {`\r\n\r\n    `private String columnName;`\r\n    `private String fieldName;`\r\n    `private Field field;`\r\n    `private DataMap dataMap;`\r\n    \r\n\r\n    `public ColumnMap(String columnName, String fieldName, DataMap dataMap) throws Exception {`\r\n        `this.columnName = columnName;`\r\n        `this.fieldName = fieldName;`\r\n        `this.dataMap = dataMap;`\r\n        `initField();`\r\n\r\n    `}`\r\n\r\n    `private void initField() throws Exception {`\r\n        `try {`\r\n\r\n            `field = dataMap.getClass().getDeclaredField(getFieldName());`\r\n            `field.setAccessible(true);`\r\n\r\n        `} catch (Exception e) {`\r\n            `throw new Exception(\"unable\tto set up field: \" + fieldName, e);`\r\n        `}`\r\n    `}`\r\n\r\n    `public void setField(Object result, Object columnValue) throws Exception {`\r\n        `try {`\r\n            `field.set(result, columnValue);`\r\n\r\n        `} catch (Exception e) {`\r\n            `throw new Exception(\"Error in setting \" + fieldName, e);`\r\n        `}`\r\n\r\n    `}`\r\n\r\n    `public Object getValue(Object subject) throws Exception {`\r\n        `try {`\r\n\r\n            `return field.get(subject);`\r\n        `} catch (Exception e) {`\r\n\r\n            `throw new Exception(e);`\r\n        `}`\r\n    `}`\r\n`}`\r\n\r\n\r\n* O mapeador é a classe que faz a integração com o banco propriamente dito:\r\n\r\n`public class Mapper {`\r\n    \r\n    `protected DataMap dataMap;`\r\n\r\n    `public Object findObject(Long key) {`\r\n        \r\n        `PreparedStatement stmt = null;`\r\n        `ResultSet rs = null;`\r\n        `DomainObject result = null;`\r\n        \r\n        `String sql = \"SELECT \" + dataMap.columnList() + \" FROM \" + dataMap.getTableName() + \" WHERE ID = ? \";`\r\n\r\n        `try {`\r\n\r\n            `stmt = DB.prepare(sql);`\r\n            `stmt.setLong(1, key.longValue());`\r\n            `rs = stmt.executeQuery();`\r\n            `rs.next();`\r\n\r\n            `result = load(rs);`\r\n\r\n        `} catch (Exception e) {`\r\n            `System.out.println(\"Erro:\" +e.getLocalizedMessage());;`\r\n        `} finally {`\r\n            `DB.cleanUp(stmt, rs);`\r\n\r\n        `}`\r\n        `return result;`\r\n    `}`\r\n\r\n    `public DomainObject load(ResultSet rs) throws Exception {`\r\n        \r\n        `Long key = new Long(rs.getLong(\"ID\"));`\r\n\r\n        `DomainObject result =  (DomainObject)dataMap.getDomainClass().newInstance();`\r\n        \r\n        `result.setID(key);`\r\n\r\n        `//uow.registerClean(result);`\r\n        `loadFields(rs, result);`\r\n        `return result;`\r\n\r\n    `}`\r\n\r\n    `private void loadFields(ResultSet rs, DomainObject result) throws Exception {`\r\n        `for (Iterator it = dataMap.getColumns(); it.hasNext();) {`\r\n\r\n            `ColumnMap columnMap = (ColumnMap) it.next();`\r\n\r\n            `Object columnValue = rs.getObject(columnMap.getColumnName());`\r\n            `columnMap.setField(result, columnValue);`\r\n\r\n        `}`\r\n\r\n    `}`\r\n\r\n    `public void update(DomainObject obj) {`\r\n        `String sql = \"UPDATE\t\" + dataMap.getTableName() + dataMap.updateList() + \" WHERE ID = ? \";`\r\n\r\n        `PreparedStatement stmt = null;`\r\n        `try {`\r\n\r\n            `stmt = DB.prepare(sql);`\r\n            `int argCount = 1;`\r\n\r\n            `for (Iterator it = dataMap.getColumns(); it.hasNext();) {`\r\n                `ColumnMap col = (ColumnMap) it.next();`\r\n                `stmt.setObject(argCount++, col.getValue(obj));`\r\n            `}`\r\n\r\n            `stmt.setLong(argCount, obj.getID().longValue());`\r\n            `stmt.executeUpdate();`\r\n        `} catch (Exception e) {`\r\n            `System.out.println(\"Erro: \" + e.getMessage());`\r\n        `} finally {`\r\n            `DB.cleanUp(stmt);`\r\n\r\n        `}`\r\n    `}`\r\n\r\n    `public Long insert(DomainObject obj) {`\r\n\r\n        `String sql = \"INSERT INTO \" + dataMap.getTableName() + \" VALUES (?\" + dataMap.insertList() + \")\";`\r\n        `PreparedStatement stmt = null;`\r\n        `try {`\r\n\r\n            `stmt = DB.prepare(sql);`\r\n            `stmt.setObject(1, obj.getID());`\r\n            `int argCount = 2;`\r\n\r\n            `for (Iterator it = dataMap.getColumns(); it.hasNext();) {`\r\n                `ColumnMap col = (ColumnMap) it.next();`\r\n                `stmt.setObject(argCount++, col.getValue(obj));`\r\n\r\n            `}`\r\n            `stmt.executeUpdate();`\r\n\r\n        `} catch (Exception e) {`\r\n            `System.out.println(\"Erro:\" +e.getMessage());`\r\n        `} finally {`\r\n            `DB.cleanUp(stmt);`\r\n\r\n        `}`\r\n        `return obj.getID();`\r\n    `}`\r\n\r\n    \r\n\r\n    `public Set findObjectsWhere(String whereClause) {`\r\n        `String sql  = \"SELECT\" + dataMap.columnList() + \" FROM \" + dataMap.getTableName() `\r\n                    `+ \" WHERE \"+ whereClause;`\r\n        `PreparedStatement stmt = null;`\r\n        `ResultSet rs = null;`\r\n\r\n        `Set result = new HashSet();`\r\n        `try {`\r\n\r\n            `stmt = DB.prepare(sql);`\r\n            `rs = stmt.executeQuery();`\r\n            `result = loadAll(rs);`\r\n\r\n        `} catch (Exception e) {`\r\n\r\n            `System.out.println(\"erro: \"+e.getLocalizedMessage());`\r\n        `} finally {`\r\n            `DB.cleanUp(stmt, rs);`\r\n\r\n        `}`\r\n        `return result;`\r\n\r\n    `}`\r\n\r\n    `public Set loadAll(ResultSet rs) throws Exception {`\r\n\r\n        `Set result = new HashSet();`\r\n        `while (rs.next()) {`\r\n\r\n            `DomainObject newObj = (DomainObject) dataMap.getDomainClass().newInstance();`\r\n            `newObj = load(rs);`\r\n\r\n            `result.add(newObj);`\r\n        `}`\r\n\r\n        `return result;`\r\n    `}`\r\n\r\n`}`\r\n\r\n* o mapeador de pessoas faz integração com o banco para um tipo de dado especifico:\r\n\r\n`public class PersonMapper  extends Mapper{`\r\n    `DataMap dataMap;`\r\n    \r\n    `protected void loadDataMap() {`\r\n\r\n        `dataMap = new DataMap(Person.class, \"people\");`\r\n        `dataMap.addColumn(\"lastname\", \"varchar\", \"lastName\");`\r\n        `dataMap.addColumn(\"firstname\", \"varchar\", \"firstName\");`\r\n        `dataMap.addColumn(\"number_of_dependents\", \"int\", \"numberOfDependents\");`\r\n    `}`\r\n\r\n    `public Person find(Long key) {`\r\n        `return (Person) findObject(key);`\r\n    `}`\r\n\r\n    `public Set findLastNamesLike(String pattern) {`\r\n        `String sql  = \"SELECT\" + dataMap.columnList()`\r\n                    `+ \"\tFROM\" + dataMap.getTableName()`\r\n                    `+ \"\tWHERE UPPER(lastName) like UPPER(?)\";`\r\n        `PreparedStatement stmt = null;`\r\n\r\n        `ResultSet rs = null;`\r\n        `try {`\r\n\r\n            `stmt = DB.prepare(sql);`\r\n            `stmt.setString(1, pattern);`\r\n            `rs = stmt.executeQuery();`\r\n            `return loadAll(rs);`\r\n\r\n        `} catch (Exception e) {`\r\n            `System.out.println(\"erro: \"+e.getMessage());`\r\n        `} finally {`\r\n            `DB.cleanUp(stmt, rs);`\r\n        `}`\r\n        `return null;`\r\n    `}`\r\n\r\n`}`\r\n\r\n\r\n* A classe DB cria uma conexão com o banco para a aplicação:\r\n\r\n`public class DB {`\r\n\r\n    `public static PreparedStatement prepare( String sql) throws SQLException {`\r\n        `Connection conexao = ConectaPostgreSQL.geraConexao();`\r\n        `return conexao.prepareStatement(sql);`\r\n    `}`\r\n\r\n    `public static void cleanUp(PreparedStatement stmt, ResultSet rs)  {`\r\n        \r\n        `try{`\r\n        `rs.close();`\r\n        `stmt.close();`\r\n        `}`\r\n        `catch(Exception e){`\r\n            `System.out.println(\"Erro:\" + e.getMessage());`\r\n        `}`\r\n    `}`\r\n\r\n    `public static void cleanUp(PreparedStatement stmt) {`\r\n        `try {`\r\n            `stmt.close();`\r\n        `} catch (SQLException ex) {`\r\n            `Logger.getLogger(DB.class.getName()).log(Level.SEVERE, null, ex);`\r\n        `}`\r\n    `}`\r\n    \r\n`}`\r\n\r\n\r\n# Query Object (Objeto de Pesquisa) \r\n\r\nUm objeto que representa uma consulta de banco de dados.\r\n\r\n\r\n![](http://martinfowler.com/eaaCatalog/queryObjectSketch.gif)\r\n\r\n## Como Funciona:\r\nUm objeto de pesquisa é um interpretador, pode-se criar a consulta fazendo referência a classes e a campos em vez de tabelas e colunas. É uma aplicação do padrão Interpretador destinado a representar uma consulta SQL.\r\nSuas principais tarefas são:\r\n* Permitir ao cliente formular consultas.\r\n* Transformar estruturas em objetos na string SQL. \r\n\r\nPode representar consultas na linguagem dos objetos na memória em vez da linguagem do esquema do banco de dados,\r\n* ou seja, usar nomes de objetos e campos em vez de usar nomes de tabelas e colunas.\r\n\r\nPara efetuar essa mudança o objeto de pesquisa precisa saber como está a estrutura do banco de dados, essa é uma habilidade que precisa de do Mapeamento de Metadados.\r\n\r\nUm uso do Objeto de pesquisa elimina pesquisas redundantes.\r\n* Se a consulta já foi vista basta consultar os objetos do Mapa de identidade, evitando assim uma ida ao banco de dados.\r\nOutra abordagem é para detectar consultas que são casos particulares de outras.\r\n\r\n* Uma variação permite que uma consulta seja especificada por um exemplo de objeto de domínio. Assim poderia ter um objeto com apenas um campo preenchido, o restante seria nulo.\r\n\r\n## Quando Usar:\r\nÉ um padrão bastante sofisticado para se construir, portanto a maioria dos projetos não usa.\r\n Vantagens desse padrão: \r\n* Manter esquemas de banco de dados encapsulados.\r\n* Suportar múltiplos banco de dados.\r\n* Otimizar consultas.\r\n* Suportar múltiplos esquemas.\r\n\r\n## Exemplo:\r\n\r\n* A classe define critérios para o objeto de consulta:\r\n\r\npublic class Criteria {\r\n\r\n    private String sqlOperator;\r\n    protected String field;\r\n    protected Object value;\r\n\r\n    public static Criteria greaterThan(String fieldName, int value) {\r\n        return Criteria.greaterThan(fieldName, new Integer(value));\r\n    }\r\n\r\n    public static Criteria greaterThan(String fieldName, Object value) {\r\n        return new Criteria(\" > \", fieldName, value);\r\n    }\r\n\r\n    private Criteria(String sql, String field, Object value) {\r\n        this.sqlOperator = sql;\r\n        this.field = field;\r\n        this.value = value;\r\n    }\r\n\r\n    public String generateSql(DataMap dataMap) throws Exception {\r\n        return dataMap.getColumnForField(field) + sqlOperator + value;\r\n    }\r\n\r\n}\r\n\r\n\r\n* Abaixo segue a representação de um objeto de pesquisa:\r\n\r\n`public class QueryObject {`\r\n\r\n    `private Mapper mapper;`\r\n    `private List criteria = new ArrayList();`\r\n\r\n    `public Set execute(DataMap dataMap) {`\r\n        `try {`\r\n            `return mapper.findObjectsWhere(generateWhereClause(dataMap));`\r\n        `} catch (Exception ex) {`\r\n            `Logger.getLogger(QueryObject.class.getName()).log(Level.SEVERE, null, ex);`\r\n        `}`\r\n        `return null;`\r\n    `}`\r\n\r\n    `private String generateWhereClause(DataMap dataMap) throws Exception {`\r\n        `StringBuffer result = new StringBuffer();`\r\n\r\n        `for (Iterator it = criteria.iterator(); it.hasNext();) {`\r\n            `Criteria c = (Criteria) it.next();`\r\n\r\n            `if (result.length() != 0) {`\r\n                `result.append(\" AND \");`\r\n            `}`\r\n\r\n            `result.append(c.generateSql(dataMap));`\r\n        `}`\r\n        `return result.toString();`\r\n    `}`\r\n\r\n`}`\r\n\r\n\r\n# Repository (Repositório)\r\n\r\n![](http://i.stack.imgur.com/IjgeZ.gif)\r\n\r\n## Como Funciona:\r\nEle é uma junção de outros padrões, ele se parece com um pequeno banco de dados orientado a objetos.\r\nExiste um objeto repositório que “simula” um banco de dados. \r\n\r\nAssim aplicação cliente não acesso a fonte de dados real, que pode ser um simples banco de dados relacional ou um fluxo XML, ou ainda a combinação de muitos bancos, no entanto ela acessa ao repositório através de métodos que recebem como parâmetros critérios usados para procurar objetos específicos que pertençam ao repositório. \r\n\r\nPodemos dizer que o repositório é uma grande coleção de dados e permite ao cliente procurar por objetos e não se preocupar com SQL. \r\n\r\nPara encontrar um objeto o cliente deve especificar os critérios de busca, tendo feito isso acontece a busca no repositório usando as informações que foram passadas, para então retornar uma lista de objetos ou um objeto do domínio que possa representar as informações que foram solicitadas.\r\n\r\nO código de um repositório se parece com uma coleção de objetos do domínio em memória. \r\nO repositório combina o Mapeamento em metadados com objeto de pesquisa, para gerar automaticamente o codigo SQL a partir dos critérios que foram passados.\r\n\r\nSua utilização pode melhorar a legibilidade e a clareza em um código que faz uso extensivo de consultas.\r\n\r\n## Quando Usar:\r\nEm sistemas grandes com muitos tipos de objetos de domínio e muitas pesquisas possíveis esse padrão reduz a quantidade o código necessário.\r\n\r\nPromove o padrão Especificação, que encapsula a consulta a ser realizada de uma forma puramente orientada a objeto.\r\n\r\n## Exemplo:\r\n\r\n Da perspectiva do objeto cliente, usando um repositório é simples. Para recuperar seus dependentes a partir do banco de dados de um objeto pessoa cria um critério de objeto que representa os critérios de pesquisa para ser combinados e envia para o repositório apropriado.\r\n\r\n`public class Person {`\r\n\r\n    `public List dependents() {`\r\n\r\n        `Repository repository = Registry.personRepository();`\r\n        `Criteria criteria = new Criteria();`\r\n        `criteria.equal(Person.BENEFACTOR, this);`\r\n\r\n        `return repository.matching(criteria);`\r\n    `}`\r\n`}`\r\n\r\nConsultas comuns podem ser acomodados com subclasses especializadas de Repository. No exemplo anterior, poderíamos fazer uma subclasse PersonRepository de Repositório e mover a criação de critérios de pesquisa no próprio repositório.\r\n\r\n`public class PersonRepository extends Repository {`\r\n\r\n    `public List dependentsOf(aPerson) {`\r\n\r\n        `Criteria criteria = new Criteria();`\r\n        `criteria.equal(Person.BENEFACTOR, aPerson);`\r\n        `return matching(criteria);`\r\n    `}`\r\n\r\n`}`\r\n\r\nO objeto pessoa em seguida, chama os dependents() método diretamente em seu repositório.\r\n\r\n`public class Person {`\r\n\r\n    `public List dependents() {`\r\n        `return Registry.personRepository().dependentsOf(this);`\r\n\r\n    `}`\r\n`}`","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}